"Шаблони. Узагальнені функціїГлавнаяНовостиПравилаО насКонтактыГлавнаяРефератыКонтрольные работыКурсовые работыДипломные работыДругие работыО нас﻿ID: 67353Название работы: Шаблони. Узагальнені функціїКатегория: ЛекцияПредметная область: Информатика, кибернетика и программированиеОписание: Поняття про шаблони Поняття про узагальнені функції Шаблонна функція з одним узагальненим типом Безпосередньо задане перевантаження узагальненої функції Шаблонна функція з двома узагальненими типами Поняття про шаблони Шаблон це один із складних і потужних засобів мови програмування C.Язык: УкраинкскийДата добавления: 2014-09-07Размер файла: 96.5 KBРаботу скачали: 2 чел.Лекція № 19Тема: Шаблони. Узагальнені функціїПланПоняття про шаблониПоняття про узагальнені функціїШаблонна функція з одним узагальненим типомБезпосередньо задане перевантаження узагальненої функціїШаблонна функція з двома узагальненими типамиПоняття про шаблониШаблон – це один із складних і потужних засобів мови програмування C++. Він не увійшов до початкової специфікації мови C++, і тільки в кінці 90-х років став невід'ємною частиною програмування нею. Шаблони дають змогу виконати одне з найважчих завдань у програмуванні – створювати програмний код, який можна використовувати для оброблення різних типів даних.Використовуючи шаблони, можна створювати узагальнені функції та узагальнені класи. В узагальненій функції (або класі) оброблюваний нею (ним) тип даних задається як параметр. Таким чином, одну і ту саму функцію або клас можна використовувати для роботи з різними типами даних, не вказуючи безпосередньо конкретні її (його) версії для оброблення кожного з типів.Поняття про узагальнені функціїУзагальнена функція визначає загальний набір операцій, які згодом використовуватимуться для оброблення даних різних типів. Тип даних, який обробляється функцією, передається їй як параметр. Використовуючи узагальнену функцію для оброблення широкого діапазону даних, можна застосувати єдину загальну процедуру. На сьогодні відомо багато алгоритмів, які мають однакову логіку оброблення різних типів даних. Наприклад, один і той самий алгоритм сортування Quicksort застосовується і для впорядкування елементів масиву цілих чисел, і до ма-сиву чисел з плинною крапкою. Відмінність тут полягає тільки в типі сортованих даних.Створюючи узагальнену функцію, можна запрограмувати роботу алгоритму незалежно від типу оброблюваних даних. Після цього компілятор автоматично згенерує коректний програмний код для типу даних, який насправді встановлюється у процесі виконання цієї функції. Загалом, створюючи узагальнену функцію, створюється функція, яка автоматично перевизначає себе саму.Узагальнена функція створюється за допомогою ключового слова template. Звичайне значення слова \"template\" точно відображає мету його застосування у мові програмування C++. Це ключове слово використовують для створення шаблону (або оболонки), який описує дії, виконувані функцією. Компіляторові ж залишається \"доповнити відсутні деталі\" відповідно до заданого значення параметра.Загальний формат визначення шаблонної функції має такий вигляд:template <class tType> тип ім'я_функції (перелік_параметрів){// тіло функції}У цьому записі елемент tType є \"заповнювачем\" для типу даних, які обробляються функцією. Це ім'я використовується в тілі самої функції. Але воно означає всього тільки заповнювач, замість якого компілятор автоматично підставить реальний тип даних при створенні конкретної версії функції. І хоча для задавання узагальненого типу в template-оголошенні за традицією застосовується ключове слово class, однак можна також використовувати ключове слово typename.Шаблонна функція з одним узагальненим типомУ наведеному нижче прикладі створюється шаблонна функція з одним узагальненим типом, яка міняє місцями значення двох змінних, що використовується під час її виклику. Оскільки загальний процес обміну значеннями змінних не залежить від їх типу, він є типовим претендентом для створення узагальненої функції.Приклад. Демонстрація механізму застосування шаблонної функції з одним узагальненимтипом// Визначення шаблонної функції.template <class aType> void swapAB(aType &a, aType &b){ aType tmp; // Створення тимчасової змінноїtmp = a;a = b;b = tmp;}void main(){ int i = 10, j = 20;double x = 10.1, y = 23.3;char a = 'x', b = 'z';cout << \"Початкові значення i, j: \" << i << \" \" << j << endl;cout << \"Початкові значення x, y: \" << x << \" \" << y << endl;cout << \"Початкові значення a, b: \" << a << \" \" << b << endl;swapAB(i, j); // Перестановка цілих чиселswapAB(x, y); // Перестановка чисел з плинною крапкоюswapAB(a, b); // Перестановка символівcout << \"Після перестановки i, j: \" << i << \" \" << j << endl;cout << \"Після перестановки x, y: \" << x << \" \" << y << endl;cout << \"Після перестановки a, b: \" << a << \" \" << b << endl;}Внаслідок виконання ця програма відображає на екрані такі результати:Початкові значення i, j: 10 20Початкові значення x, у: 10.1 23.3Початкові значення a, b: x zПісля перестановки i, j: 20 10Після перестановки x, у: 23.3 10.1Після перестановки a, b: z xОтже, розглянемо уважно код програми. Рядок template <class aType> void swapAB(aType &a, aType &b) повідомляє компілятор, по-перше, що створюється шаблон, і, по-друге, що тут починається узагальнене визначення шаблонної функції. Позначення aType є узагальненим типом, який використовується як \"заповнювач\". За template-заголовком знаходиться оголошення функції swapAB(), у якому символ aType означає тип даних для значень, які мінятимуться місцями. У функції main() продемонстровано виклик функції swapAB() з використанням трьох різних типів даних: int, double і char. Оскільки функція swapAB() є узагальненою, то компілятор автоматично створює три версії функції swapAB(): одну для обміну цілих чисел, другу для обміну чисел з плинною крапкою і третю для обміну символів.Тут необхідно уточнити деякі важливі терміни, пов'язані з шаблонами. По-перше, узагальнена функція (тобто функція, оголошення якої передує template-настанові) також називається шаблонною функцією. Обидва терміни використовуються як взаємозамінні. Коли компілятор створює конкретну версію цієї функції, то вважають, що створюється її спеціалізація (або конкретизація). Спеціалізація також називається породженою функцією (generated function). Дію породження функції визначають як її реалізацію (instantiating). Іншими словами, породжувана функція є конкретним примірником шаблонної функції.Оскільки мова програмування C++ не розпізнає символ кінця рядка як ознаку кінця настанови, то template-частина визначення узагальненої функції може не знаходитися в одному рядку з іменем цієї функції. У наведеному нижче прикладі показано ще один (достатньо поширений) спосіб форматування функції swapAB():template <class aType>void swapAB(aType &a, aType &b){ aType tmp; // Створення тимчасової змінноїtmp = a;a = b;b = tmp;}При використанні цього формату важливо розуміти, що між template-настановою і початком визначення узагальненої функції ніякі інші настанови знаходитися не можуть. Наприклад, наведений нижче код програми не відкомпілюється:// Цей програмний код не відкомпілюєтьсяtemplate <class aType>int i; // Тут помилка!void swapAB(aType &a, aType &b){ aType tmp; // Створення тимчасової змінноїtmp = a;a = b;b = tmp;}Як зазначено в коментарі, template-специфікація повинна знаходитися безпосередньо перед визначенням функції. Між ними не може знаходитися ні настанова оголошення змінної, ні будь-яка інша настанова.Безпосередньо задане перевизначення узагальненої функціїНезважаючи на те, що узагальнена функція сама перевизначається в міру потреби, однак це можна робити і безпосередньо. Формально цей процес називається безпосередньою спеціалізацією. При перевизначенні узагальнена функція перевизначається \"на вигоду\" цієї конкретної версії. Розглянемо, наприклад, наведену нижче програму, яка є переробленою версію першого прикладу.Приклад. Демонстрація механізму перевизначення шаблонної функціїtemplate <class aType> void swapAB(aType &a, aType &b){ aType tmp; // Створення тимчасової змінноїtmp = a;a = b;b = tmp;cout << \"Виконується шаблонна функція swapAB\" << endl;}// Ця функція перевизначає узагальнену версію функції swapAB() для int-параметрів.void swapAB(int &a, int &b){ int tmp;tmp = a;a = b;b = tmp;cout << \"Це int-спеціалізація функції swapAB\" << endl;}void main(){ int i = 10, j = 20;double x = 10.1, y = 23.3;char a = 'x', b = 'z';cout << \"Початкові значення i, j: \" << i << \" \" << j << endl;cout << \"Початкові значення x, y: \" << x << \" \" << y << endl;cout << \"Початкові значення a, b: \" << a << \" \" << b << endl;swapAB(i, j); // Викликається безпосередньо перевизначена функція swapAB().swapAB(x, y); // Викликається узагальнена функція swapAB().swapAB(a, b); // Викликається узагальнена функція swapAB().cout << \"Після перестановки i, j: \" << i << \" \" << j << endl;cout << \"Після перестановки x, y: \" << x << \" \" << y << endl;cout << \"Після перестановки a, b: \" << a << \" \" << b << endl;}Внаслідок виконання ця програма відображає на екрані такі результати:Початкові значення i, j: 10 20Початкові значення x, у: 10.1 23.3Початкові значення a, b: x zЦе int-спеціалізація функції swapAB.Виконується шаблонна функція swapAB.Виконується шаблонна функція swapAB.Після перестановки i, j: 20 10Після перестановки x, у: 23.3 10.1Після перестановки a, b: z xЯк зазначено в коментарях до цієї програми, під час виклику функції swapAB(i,j) виконується безпосередньо перевизначена версія функції swapAB(), яку визначено у програмі. Компілятор у цьому випадку не генерує узагальнену функцію swapAB(), оскільки вона перевизначається безпосередньо заданим варіантом перевизначеної функції. Для позначення безпосередньої спеціалізації функції можна використовувати новий альтернативний синтаксис, що містить ключове слово template. Наприклад, якщо задати спеціалізацію з використанням цього альтернативного синтаксису, то перевизначена версія функції swapAB() з попереднього коду програми виглядатиме так:// Використання нового синтаксису задавання спеціалізаціїtemplate<> void swapAB<int>(int &a, int &b){ int tmp;tmp = a;a = b;b = tmp;cout << \"Це int-спеціалізація функції swapAB\" << endl;}Як бачите, в новому синтаксисі для позначення спеціалізації використовують конструкцію template<>. Тип даних, для яких створюється ця спеціалізація, вказується в кутових дужках після імені функції. Для задавання будь-якого типу узагальненої функції використовується один і той самий синтаксис. На даний момент жоден з синтаксичних способів задавання спеціалізації не має жодних переваг перед іншим, але з погляду перспективи розвитку мови програмування, можливо, все ж таки краще використовувати новий стиль.Безпосередня спеціалізація шаблону дає змогу спроектувати версію узагальненої функції з розрахунку на деяку унікальну ситуацію, щоб, можливо, скористатися перевагами підвищеної швидкодії програми тільки для одного типу даних. Але, як правило, якщо виникає потреба мати різні версії функції для різних типів даних, то доцільно використовувати перевантажені функції, а не шаблони.Шаблонна функція з двома узагальненими типамиУ template-настанові можна визначити декілька узагальнених типів даних, використовуючи перелік елементів, розділених між собою комами. Наприклад, у наведеному нижче коді програми створюється шаблонна функція з двома узагальненими типами.Приклад. Демонстрація механізму застосування шаблонної функції з двома узагальненимитипамиtemplate <class aType, class bType> void FunC(aType a, bType b){ cout << a << \" \" << b << endl;}void main(){ FunC(10, \"Привіт\");FunC(0.23, 10L);}У наведеному прикладі у процесі виконання функції main(), коли компілятор генерує конкретні примірники функції FunC(), заповнювачі типів aType і bType замінюються спочатку парою типів даних int і char *, а потім парою double і long відповідно.А также другие работы, которые могут Вас заинтересовать58651. Конспект урока Урок развития и культуры речи. Национальные костюмы 33.5 KBЦель: Развивать навыки чтения, умения объяснять значение слов, исходя из контекста (словарь); работать над устным сочинением-описанием по картине. Повторить и обсудить изученный материал по теме Состав слова. Орфография58652. Конспект урока Неопределенная форма глаголов 54.5 KBЦель урока: Научить правильно писать возвратные глаголы в неопределенной форме. Оборудование урока: для учителя: доска для учеников: учебник тетрадь. Эскиз оформления доски что и где из наглядного материала из записей расположите на доске...58653. Конспект урока Правописание разделительных Ь и Ъ знаков 53 KBРегулятивные: принимать и сохранять учебную задачу учитывать выделенные учителем ориентиры действия планировать свои действия осуществлять...58657. Научная статья ТРЕБОВАНИЯ К СОВРЕМЕННОМУ УРОКУ РУССКОГО ЯЗЫКА 44.5 KBВ практике обучения учитель планирует три разные задачи намечает три параллельные линии. Если подойти с учетом современного толкования понятий развитие и воспитание в процессе обучения то станет ясно: в уроке должны быть выдержаны не три линии а одна обеспечивающая...58658. Конспект урока Правило переноса слов 59 KBФорма организации деятельности: самостоятельная работа фронтальная работа взаимопроверка работа в парах. Приемы: работа с учебником; составление схем; взаимоконтроль; групповая работа. Самостоятельная работа с самопроверкой по эталону.58659. Конспект урока Имена собственные 44 KBНа экране видеофрагмент мультфильма Трое из Простоквашино затем появляется тема урока. На экране появляется рубрика Словарный диктант и галчонок Хватайка. Проверьте записанное в тетради с ответами на экране.© \"Пятифан\" http://5fan.ruВсе права на сайт и размещенные работызащищены законом об авторском праве."
