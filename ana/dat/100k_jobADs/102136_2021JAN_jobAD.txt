"glusterfs.git -index : glusterfs.gitbug-deprecated dht-stale-layout-fixes exp experimental heal-info master release-2.0 release-3.0 release-3.1 release-3.10 release-3.11 release-3.12 release-3.13 release-3.2 release-3.3 release-3.4 release-3.5 release-3.6 release-3.7 release-3.8 release-3.8-fb release-3.9 release-4.0 release-4.1 release-5 release-6 release-7 release-8 round-robin2 testing-regression-jobsummaryrefslogtreecommitdiffstatslog msg author committer rangepath: root/api/src/glfs-handleops.cdiff optionscontext: 12345678910152025303540space: includeignoremode: unifiedssdiffstat onlyDiffstat (limited to 'api/src/glfs-handleops.c')-rw-r--r-- api/src/glfs-handleops.c 2381 files changed, 155 insertions, 83 deletionsdiff --git a/api/src/glfs-handleops.c b/api/src/glfs-handleops.cindex ba46838..2ee3820 100644--- a/api/src/glfs-handleops.c+++ b/api/src/glfs-handleops.c@@ -61,8 +61,8 @@ glfs_iatt_from_stat (struct stat *stat, int valid, struct iatt *iatt,}struct glfs_object *-glfs_h_lookupat (struct glfs *fs, struct glfs_object *parent,- const char *path, struct stat *stat)+pub_glfs_h_lookupat (struct glfs *fs, struct glfs_object *parent,+ const char *path, struct stat *stat){int ret = 0;xlator_t *subvol = NULL;@@ -80,7 +80,7 @@ glfs_h_lookupat (struct glfs *fs, struct glfs_object *parent,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {errno = EIO;goto out;@@ -96,8 +96,8 @@ glfs_h_lookupat (struct glfs *fs, struct glfs_object *parent,}/* fop/op */- ret = glfs_resolve_at (fs, subvol, inode, path, &loc, &iatt,- 0 /*TODO: links? */, 0);+ ret = priv_glfs_resolve_at (fs, subvol, inode, path, &loc, &iatt,+ 0 /*TODO: links? */, 0);/* populate out args */if (!ret) {@@ -113,13 +113,16 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return object;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_lookupat, 3.4.2);++int-glfs_h_stat (struct glfs *fs, struct glfs_object *object, struct stat *stat)+pub_glfs_h_stat (struct glfs *fs, struct glfs_object *object, struct stat *stat){int ret = -1;xlator_t *subvol = NULL;@@ -136,7 +139,7 @@ glfs_h_stat (struct glfs *fs, struct glfs_object *object, struct stat *stat)__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -167,13 +170,17 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_stat, 3.4.2);++int-glfs_h_getattrs (struct glfs *fs, struct glfs_object *object, struct stat *stat)+pub_glfs_h_getattrs (struct glfs *fs, struct glfs_object *object,+ struct stat *stat){int ret = 0;xlator_t *subvol = NULL;@@ -189,7 +196,7 @@ glfs_h_getattrs (struct glfs *fs, struct glfs_object *object, struct stat *stat)__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -215,14 +222,17 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_getattrs, 3.4.2);++int-glfs_h_getxattrs (struct glfs *fs, struct glfs_object *object, const char *name,- void *value, size_t size)+pub_glfs_h_getxattrs (struct glfs *fs, struct glfs_object *object,+ const char *name, void *value, size_t size){int ret = 0;xlator_t *subvol = NULL;@@ -239,7 +249,7 @@ glfs_h_getxattrs (struct glfs *fs, struct glfs_object *object, const char *name,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -274,14 +284,16 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_getxattrs, 3.5.1);+int-glfs_h_setattrs (struct glfs *fs, struct glfs_object *object, struct stat *stat,- int valid)+pub_glfs_h_setattrs (struct glfs *fs, struct glfs_object *object,+ struct stat *stat, int valid){int ret = -1;xlator_t *subvol = NULL;@@ -299,7 +311,7 @@ glfs_h_setattrs (struct glfs *fs, struct glfs_object *object, struct stat *stat,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -328,14 +340,18 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_setattrs, 3.4.2);++int-glfs_h_setxattrs (struct glfs *fs, struct glfs_object *object, const char *name,- const void *value, size_t size, int flags)+pub_glfs_h_setxattrs (struct glfs *fs, struct glfs_object *object,+ const char *name, const void *value, size_t size,+ int flags){int ret = -1;xlator_t *subvol = NULL;@@ -353,7 +369,7 @@ glfs_h_setxattrs (struct glfs *fs, struct glfs_object *object, const char *name,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -390,13 +406,17 @@ out:if (xattr)dict_unref (xattr);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_setxattrs, 3.5.0);++int-glfs_h_removexattrs (struct glfs *fs, struct glfs_object *object, const char *name)+pub_glfs_h_removexattrs (struct glfs *fs, struct glfs_object *object,+ const char *name){int ret = -1;xlator_t *subvol = NULL;@@ -412,7 +432,7 @@ glfs_h_removexattrs (struct glfs *fs, struct glfs_object *object, const char *na__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -439,13 +459,16 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_removexattrs, 3.5.1);++struct glfs_fd *-glfs_h_open (struct glfs *fs, struct glfs_object *object, int flags)+pub_glfs_h_open (struct glfs *fs, struct glfs_object *object, int flags){int ret = -1;struct glfs_fd *glfd = NULL;@@ -462,7 +485,7 @@ glfs_h_open (struct glfs *fs, struct glfs_object *object, int flags)__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {errno = EIO;goto out;@@ -523,14 +546,17 @@ out:glfs_fd_bind (glfd);}- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return glfd;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_open, 3.4.2);++struct glfs_object *-glfs_h_creat (struct glfs *fs, struct glfs_object *parent, const char *path,- int flags, mode_t mode, struct stat *stat)+pub_glfs_h_creat (struct glfs *fs, struct glfs_object *parent, const char *path,+ int flags, mode_t mode, struct stat *stat){int ret = -1;struct glfs_fd *glfd = NULL;@@ -551,7 +577,7 @@ glfs_h_creat (struct glfs *fs, struct glfs_object *parent, const char *path,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -635,14 +661,17 @@ out:glfd = NULL;}- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return object;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_creat, 3.4.2);++struct glfs_object *-glfs_h_mkdir (struct glfs *fs, struct glfs_object *parent, const char *path,- mode_t mode, struct stat *stat)+pub_glfs_h_mkdir (struct glfs *fs, struct glfs_object *parent, const char *path,+ mode_t mode, struct stat *stat){int ret = -1;xlator_t *subvol = NULL;@@ -662,7 +691,7 @@ glfs_h_mkdir (struct glfs *fs, struct glfs_object *parent, const char *path,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -724,14 +753,17 @@ out:if (xattr_req)dict_unref (xattr_req);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return object;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_mkdir, 3.4.2);++struct glfs_object *-glfs_h_mknod (struct glfs *fs, struct glfs_object *parent, const char *path,- mode_t mode, dev_t dev, struct stat *stat)+pub_glfs_h_mknod (struct glfs *fs, struct glfs_object *parent, const char *path,+ mode_t mode, dev_t dev, struct stat *stat){int ret = -1;xlator_t *subvol = NULL;@@ -751,7 +783,7 @@ glfs_h_mknod (struct glfs *fs, struct glfs_object *parent, const char *path,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -812,13 +844,16 @@ out:if (xattr_req)dict_unref (xattr_req);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return object;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_mknod, 3.4.2);++int-glfs_h_unlink (struct glfs *fs, struct glfs_object *parent, const char *path)+pub_glfs_h_unlink (struct glfs *fs, struct glfs_object *parent, const char *path){int ret = -1;xlator_t *subvol = NULL;@@ -834,7 +869,7 @@ glfs_h_unlink (struct glfs *fs, struct glfs_object *parent, const char *path)__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if ( !subvol ) {ret = -1;errno = EIO;@@ -848,7 +883,7 @@ glfs_h_unlink (struct glfs *fs, struct glfs_object *parent, const char *path)goto out;}- ret = glfs_resolve_at (fs, subvol, inode, path, &loc, NULL, 0 , 0);+ ret = priv_glfs_resolve_at (fs, subvol, inode, path, &loc, NULL, 0 , 0);if (ret != 0) {goto out;}@@ -876,13 +911,16 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_unlink, 3.4.2);++struct glfs_fd *-glfs_h_opendir (struct glfs *fs, struct glfs_object *object)+pub_glfs_h_opendir (struct glfs *fs, struct glfs_object *object){int ret = -1;struct glfs_fd *glfd = NULL;@@ -899,7 +937,7 @@ glfs_h_opendir (struct glfs *fs, struct glfs_object *object)__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -952,13 +990,16 @@ out:glfs_fd_bind (glfd);}- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return glfd;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_opendir, 3.4.2);++int-glfs_h_access (struct glfs *fs, struct glfs_object *object, int mask)+pub_glfs_h_access (struct glfs *fs, struct glfs_object *object, int mask){int ret = -1;xlator_t *subvol = NULL;@@ -974,7 +1015,7 @@ glfs_h_access (struct glfs *fs, struct glfs_object *object, int mask)__glfs_entry_fs (fs);/* get the active volume */-	subvol = glfs_active_subvol (fs);+	subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -1003,14 +1044,17 @@ out:inode_unref (inode);-	glfs_subvol_done (fs, subvol);+	priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_access, 3.6.0);++ssize_t-glfs_h_extract_handle (struct glfs_object *object, unsigned char *handle,- int len)+pub_glfs_h_extract_handle (struct glfs_object *object, unsigned char *handle,+ int len){ssize_t ret = -1;@@ -1039,9 +1083,12 @@ out:return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_extract_handle, 3.4.2);++struct glfs_object *-glfs_h_create_from_handle (struct glfs *fs, unsigned char *handle, int len,- struct stat *stat)+pub_glfs_h_create_from_handle (struct glfs *fs, unsigned char *handle, int len,+ struct stat *stat){loc_t loc = {0, };int ret = -1;@@ -1059,7 +1106,7 @@ glfs_h_create_from_handle (struct glfs *fs, unsigned char *handle, int len,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {errno = EIO;goto out;@@ -1118,13 +1165,16 @@ out:/* TODO: Check where the inode ref is being held? */loc_wipe (&loc);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return object;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_create_from_handle, 3.4.2);++int-glfs_h_close (struct glfs_object *object)+pub_glfs_h_close (struct glfs_object *object){/* Release the held reference */inode_unref (object->inode);@@ -1133,8 +1183,11 @@ glfs_h_close (struct glfs_object *object)return 0;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_close, 3.4.2);++int-glfs_h_truncate (struct glfs *fs, struct glfs_object *object, off_t offset)+pub_glfs_h_truncate (struct glfs *fs, struct glfs_object *object, off_t offset){loc_t loc = {0, };int ret = -1;@@ -1150,7 +1203,7 @@ glfs_h_truncate (struct glfs *fs, struct glfs_object *object, off_t offset)__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -1180,14 +1233,17 @@ out:if (inode)inode_unref (inode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_truncate, 3.4.2);++struct glfs_object *-glfs_h_symlink (struct glfs *fs, struct glfs_object *parent, const char *name,- const char *data, struct stat *stat)+pub_glfs_h_symlink (struct glfs *fs, struct glfs_object *parent,+ const char *name, const char *data, struct stat *stat){int ret = -1;xlator_t *subvol = NULL;@@ -1208,7 +1264,7 @@ glfs_h_symlink (struct glfs *fs, struct glfs_object *parent, const char *name,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -1263,7 +1319,7 @@ glfs_h_symlink (struct glfs *fs, struct glfs_object *parent, const char *name,out:if (ret && object != NULL) {- glfs_h_close (object);+ pub_glfs_h_close (object);object = NULL;}@@ -1275,14 +1331,17 @@ out:if (xattr_req)dict_unref (xattr_req);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return object;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_symlink, 3.4.2);++int-glfs_h_readlink (struct glfs *fs, struct glfs_object *object, char *buf,- size_t bufsiz)+pub_glfs_h_readlink (struct glfs *fs, struct glfs_object *object, char *buf,+ size_t bufsiz){loc_t loc = {0, };int ret = -1;@@ -1299,7 +1358,7 @@ glfs_h_readlink (struct glfs *fs, struct glfs_object *object, char *buf,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -1332,13 +1391,19 @@ out:if (linkval)GF_FREE (linkval);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_readlink, 3.4.2);+++extern int+priv_glfs_loc_touchup (loc_t *);+int-glfs_h_link (struct glfs *fs, struct glfs_object *linksrc,+pub_glfs_h_link (struct glfs *fs, struct glfs_object *linksrc,struct glfs_object *parent, const char *name){int ret = -1;@@ -1358,7 +1423,7 @@ glfs_h_link (struct glfs *fs, struct glfs_object *linksrc,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if (!subvol) {ret = -1;errno = EIO;@@ -1390,7 +1455,7 @@ glfs_h_link (struct glfs *fs, struct glfs_object *linksrc,/* setup newloc based on parent */newloc.parent = inode_ref (pinode);newloc.name = name;- ret = glfs_loc_touchup (&newloc);+ ret = priv_glfs_loc_touchup (&newloc);if (ret != 0) {errno = EINVAL;goto out;@@ -1418,14 +1483,18 @@ out:if (pinode)inode_unref (pinode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}+GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_link, 3.4.2);++int-glfs_h_rename (struct glfs *fs, struct glfs_object *olddir, const char *oldname,- struct glfs_object *newdir, const char *newname)+pub_glfs_h_rename (struct glfs *fs, struct glfs_object *olddir,+ const char *oldname, struct glfs_object *newdir,+ const char *newname){int ret = -1;xlator_t *subvol = NULL;@@ -1446,7 +1515,7 @@ glfs_h_rename (struct glfs *fs, struct glfs_object *olddir, const char *oldname,__glfs_entry_fs (fs);/* get the active volume */- subvol = glfs_active_subvol (fs);+ subvol = priv_glfs_active_subvol (fs);if ( !subvol ) {ret = -1;errno = EIO;@@ -1460,8 +1529,8 @@ glfs_h_rename (struct glfs *fs, struct glfs_object *olddir, const char *oldname,goto out;}- ret = glfs_resolve_at (fs, subvol, oldpinode, oldname, &oldloc,- &oldiatt, 0 , 0);+ ret = priv_glfs_resolve_at (fs, subvol, oldpinode, oldname, &oldloc,+ &oldiatt, 0 , 0);if (ret != 0) {goto out;}@@ -1473,8 +1542,8 @@ glfs_h_rename (struct glfs *fs, struct glfs_object *olddir, const char *oldname,goto out;}- ret = glfs_resolve_at (fs, subvol, newpinode, newname, &newloc,- &newiatt, 0, 0);+ ret = priv_glfs_resolve_at (fs, subvol, newpinode, newname, &newloc,+ &newiatt, 0, 0);if (ret && errno != ENOENT && newloc.parent)goto out;@@ -1511,7 +1580,10 @@ out:if (newpinode)inode_unref (newpinode);- glfs_subvol_done (fs, subvol);+ priv_glfs_subvol_done (fs, subvol);return ret;}++GFAPI_SYMVER_PUBLIC_DEFAULT(glfs_h_rename, 3.4.2);+generated by cgit v1.1 at 2021-01-28 04:52:04 +0000"
