"Lasell University Jobs | DiversityJobs.comLasell University | DiversityJobs.comEMPLOYER / POST JOBSJOBSEEKERS / UPLOAD RESUMEFacebookTwitterLinkedInTop EmployersJob FairsArticlesCareer AdviceWorkplace DiversityCareer StoriesEmployers / Post JobsFind JobsUpload ResumeSearch ArticlesSearch ArticlesLasell is a dynamic environment that embraces challenges, grasps new opportunities, and forges direct connections with professional outcomes so our students are prepared to thrive in the 21st century. Located In Newton, MA.Lasell Works is a unique career preparation program designed to launch students into their professional futures. Over the course of four years, students who participate in the Lasell Works program receive tuition reduction and instruction from expert faculty, which helps them develop into marketable and successful employees in their fields.A distinction of the Lasell Works program is that during sophomore year, students live off campus, take their classes online, and work in their professional field of study. Students accepted into the Lasell Works program pay less in tuition each year they are enrolled in the program. Lasell Works students complete a variety of professional seminars emphasizing leadership, financial literacy, and professional and career development.﻿\"); //toolTipShow() return false; } return true; }; // assuming we're only autocompleting/preselecting geos with s for countries (i.e. don't require typed country info, e.g. cc geo) this.countryPreselect = function(country) { // TODO: test some preexisting/prepopulated non-US country to verify it doesn't get overwritten if (country.length > 0 && country.val() == \"\" && that.config.fbCountry) { country.val(that.config.fbCountry); } }; this.stateDisable = function(state) { if (state.length > 0) { state.attr('readonly', 'readonly'); } //alert(state.val() + \"....\" + state.attr(\"readonly\")); }; // use cases: cc geo // selector should not be a css class, or autocomplete will stop working after postback over cssErrorClass-ed elements this.stateAutocomplete = function(selector, myClass) { var url = that.getAppUrl('/geoac/s/s'); jQuery(selector).blur(function() { jQuery(this).removeClass(\"cityLoading citySelect cityNotFound\"); }).keydown(function() { jQuery(this).removeClass(\"cityLoading citySelect cityNotFound\"); }).autocomplete({ width:100, minLength: 1, source: function(request, response) { var state = jQuery(this.element); // TODO: can't be used with non-selectable countries, e.g. CC var country = that.countryElementFromState(state.attr(\"id\")); var args = { ll: that.getLonLatArg(), t: request.term }; jQuery.getJSON(url, args, function(results) { if (results.length == 0) { state.removeClass(\"cityLoading citySelect\").addClass(\"cityNotFound\"); } response(jQuery.map(results, function (n) { return { label: name, value: name }; })); } ); }, create: function(event, ui) { }, search: function(event, ui) { }, open: function(event, ui) { var state = jQuery(this.element); state.removeClass(\"cityLoading cityNotFound\").addClass(\"citySelect\"); }, select: function(event, ui) { // simply set the chosen option label as value var state = jQuery(this.element); state.removeClass(\"citySelect\"); } }); if (myClass != null) { jQuery(selector).each(function(i, e) { jQuery(e).data('autocomplete').menu.element.addClass(myClass); }); } else { jQuery(selector).each(function(i, e) { jQuery(e).data('autocomplete').menu.element.addClass(\"defaultAutoInput\"); }); } }; // selector should not be a css class, or autocomplete will stop working after postback over cssErrorClass-ed elements this.zipAutocomplete = function(selector, myClass) { var isThisCity = false; // not to be used on job search var url = that.getAppUrl('/geoac/s/z'); jQuery(selector).blur(function() { jQuery(this).removeClass(\"cityLoading citySelect cityNotFound\"); }).keydown(function() { jQuery(this).removeClass(\"cityLoading citySelect cityNotFound\"); }).autocomplete({ width:100, // wait for at least (and at most) 5 chars minLength: 5, source: function(request, response) { var fields = that.fields(isThisCity, this.element); var postalCode = fields.postalCode; // TODO: can't be used with non-selectable countries, e.g. CC, search var country = fields.country; var matchesZipRegex = that.matchesZipRegex(request.term); // don't bother searching if not a zipcode if (!matchesZipRegex) { postalCode.removeClass(\"cityLoading citySelect\"); return; } var args = { ll: that.getLonLatArg(), t: request.term }; jQuery.getJSON(url, args, function(results) { if (results.length == 0) { // not-found zipcodes are now disallowed // TODO: test not found: zip postalCode.removeClass(\"cityLoading citySelect\").addClass(\"cityNotFound\"); //	postalCode.removeClass(\"cityLoading citySelect\"); } response(jQuery.map(results, function (n) { zips = n.zipcode; // try to display the city zipcode, either the first found if isCityMode or the one typed (if found) if (zips != null && zips.constructor.toString().indexOf(\"Array\") != -1 && zips.length > 0) { zip = zips[0]; if (matchesZipRegex) { for (i = 0; i < zips.length; i++) { if (request.term == zips[i]) { zip = zips[i]; break; } } } } else { zip = \"\"; } zipPre = matchesZipRegex && zip != null && zip.length > 0 ? \"(\" + zip + \") \" : \"\"; adm1 = n.country_code == \"US\" ? n.adm1_code : n.adm1_name; adm1 = that.isBlank(adm1) ? \"\" : \", \" + adm1; adm2 = n.adm2_name; // showing between parentheses to avoid confusion when typing ', state' //adm2 = that.isBlank(adm2) ? \"\" : \", \" + adm2; adm2 = that.isBlank(adm2) ? \"\" : \" (\" + adm2 + \")\"; //alert(matchesZipRegex +\",\"+zip+\",\"+\"->\"+zipPre); return { label: zipPre + n.name + adm1 + adm2, // simply use the typed zipcode as value value: request.term, //gfid: n.feature_id, gfid: n.gac_id, state: n.adm1_name, city: n.name, //postalCode: zip, country: n.country_code, countryName: n.country_name }; })); } ); }, create: function(event, ui) { var fields = that.fields(isThisCity, this); var city = fields.city; var gfid = fields.gfid; var state = fields.state; var postalCode = fields.postalCode; var country = fields.country; if (gfid.length > 0) { if (that.isBlank(gfid.val())) { // we might be simply filling in a city's zipcode if the DB returned none, clearing city here anyway as gfid is empty city.val(\"\"); postalCode.val(\"\"); } } // this autocomplete implies that state is derived from other fields that.stateDisable(state); that.countryPreselect(country); }, search: function(event, ui) { var fields = that.fields(isThisCity, this); var postalCode = fields.postalCode; var gfid = fields.gfid; var state = fields.state; var country = fields.country; var countryName = fields.countryName; // we might be simply filling in a city's zipcode if the DB returned none //if (gfid.length > 0) gfid.val(null); //if (state.length > 0) state.val(null); // country now determines //if (country.length > 0) country.val(\"\"); //if (countryName.length > 0) countryName.val(\"\"); //var matchesZipRegex = that.matchesZipRegex(postalCode.val()); // not-found zipcodes are now disallowed postalCode.removeClass(\"cityNotFound citySelect\").addClass(\"cityLoading\"); //postalCode.removeClass(\"cityNotFound cityLoading citySelect\"); }, open: function(event, ui) { var fields = that.fields(isThisCity, this); var postalCode = fields.postalCode; postalCode.removeClass(\"cityLoading cityNotFound\").addClass(\"citySelect\"); }, select: function(event, ui) { var fields = that.fields(isThisCity, this); var postalCode = fields.postalCode; var gfid = fields.gfid; var state = fields.state; var country = fields.country; var countryName = fields.countryName; var city = fields.city; if (gfid.length > 0) gfid.val(ui.item.gfid); // not-found zipcodes are allowed because zip DBs get outdated, etc if (city.length > 0) { city.val(ui.item.city); //if (ui.item.city.length > 0) jQuery(\".\" + city.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); } if (state.length > 0) { state.val(ui.item.state); //if (ui.item.state.length > 0) jQuery(\".\" + state.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); } // country now determines //if (country.length > 0) { //	country.val(ui.item.country); //	if (ui.item.country.length > 0) jQuery(\".\" + country.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); //} //if (countryName.length > 0) { //	countryName.val(ui.item.countryName); //	if (ui.item.countryName.length > 0) jQuery(\".\" + countryName.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); //} postalCode.removeClass(\"citySelect\"); } }); if (myClass != null) { jQuery(selector).each(function(i, e) { jQuery(e).data('autocomplete').menu.element.addClass(myClass); }); } else { jQuery(selector).each(function(i, e) { jQuery(e).data('autocomplete').menu.element.addClass(\"defaultAutoInput\"); }); } }; // selector should not be a css class, or autocomplete will stop working after postback over cssErrorClass-ed elements this.cityAutocomplete = function(selector, alsoAllowed, myClass) { var isThisCity = true; var constants = new GeoConstants(); var allowStates = that.hasBit(alsoAllowed, constants.STATE); var allowZipcodes = that.hasBit(alsoAllowed, constants.ZIP); //alert(selector+\":\"+isCondensedMode+\",\"+isUsZipMode+\",\"+isCityMode); // in condensed mode: assume we're using a city field, allow/search for zip or city in city field, upon selecting a suggested option keep the state name if available // in non-condensed mode: assume we're using a city/zip field depending on the city/zip mode, search for either zip or city in that field, upon selecting a suggested option keep only the city name in the city field // if allowZipCodes // - city field will //var port = window.location.port ? ':' + window.location.port : ''; //var url = window.location.protocol + window.location.host /*+ port*/ + appBase; // the selector might end up bringing more than one form //var cityElement = jQuery(selector); //jQuery(selector).parents(\"form\").first().submit(function() { jQuery(selector).each(function() { var cityElement = jQuery(this); var cityElementForm = cityElement.parents(\"form\").first(); cityElementForm.submit(function() { return that.checkSelection(cityElement, alsoAllowed); }); }); // see http://blog.ov3rk1ll.com/2012/03/jquery-ui-autocomplete-combobox-pick-1st-item-with-enter-key/ jQuery(selector).keypress(function(event) { if (event.which == 13 && jQuery('ul.ui-autocomplete').is(':visible')) { var li = jQuery('li.ui-menu-item:first')[0]; //var item = jQuery(li).data(\"item.autocomplete\"); var item = jQuery(li).data(\"uiAutocompleteItem\"); if (item.gfid && item.gfid.length > 0) { //input.data(\"autocomplete\").options.select(event, {item: item}); var fields = that.fieldsFromEvent(isThisCity, event); var city = fields.city; var gfid = fields.gfid; // confirm visibility if (city.autocomplete('widget').is(':visible')) { //city.val(item.value); //if (gfid.length > 0) gfid.val(item.gfid); //city.data(\"autocomplete\").options.select(event, {item: item}); city.autocomplete(\"option\").select(event, {item: item}); //city.autocomplete(\"close\"); city.blur(); // no need to trigger submit() (event's default); unable to prevent submit using preventDefault/stopPropagation/return false (which prevent selection instead) //jQuery(this).parents(\"form\").first().submit(); } } } //return that.preventSubmit(event); }); //jQuery(selector).keyup(function(event) { //	return that.preventSubmit(event); //}); jQuery(selector).blur(function(event) { var fields = that.fieldsFromEvent(isThisCity, event); var city = fields.city; var gfid = fields.gfid; var error = that.signalsError(gfid); if (!error && gfid.length > 0) { if (that.isBlank(gfid.val()) && !that.isBlank(city.val()) && jQuery('ul.ui-autocomplete').is(':visible')) { var li = jQuery('li.ui-menu-item:first')[0]; //var item = jQuery(li).data(\"item.autocomplete\"); var item = jQuery(li).data(\"uiAutocompleteItem\"); var matchesAsZip = item.name && that.matchesZipRegex(item.name) && item.name == city.val().trim(); //var matchesAsLabel = item.label && item.label == city.val().trim().toLowerCase(); //if (item.gfid && item.gfid.length > 0 && (matchesAsZip || matchesAsLabel)) { if (item.gfid && item.gfid.length > 0 && matchesAsZip) { //input.data(\"autocomplete\").options.select(event, {item: item}); // confirm visibility if (city.autocomplete('widget').is(':visible')) { //city.val(item.value); //if (gfid.length > 0) gfid.val(item.gfid); //city.data(\"autocomplete\").options.select(event, {item: item}); city.autocomplete(\"option\").select(event, {item: item}); //city.autocomplete(\"close\"); } } } } jQuery(this).removeClass(\"cityLoading citySelect cityNotFound\"); }).keydown(function(event) { var fields = that.fields(isThisCity, this); var city = fields.city; var gfid = fields.gfid; var error = that.signalsError(gfid); //if (that.isBlank(city.val())) { if (!error && that.keyChangesValue(event)) { //that.log(\"keydown: clearing gfid\"); if (gfid.length > 0) gfid.val(null); } jQuery(this).removeClass(\"cityLoading citySelect cityNotFound\"); //return that.preventSubmit(event); }).autocomplete({ width:100, minLength: 1, source: function(request, response) { var fields = that.fields(isThisCity, this.element); var city = fields.city; var gfid = fields.gfid; var gfidTermlist = fields.gfidTermlist; // if execution got to this point, ui autocomplete is probably supported, let the server know it's enabled var gfidEnabled = fields.gfidEnabled; that.enable(gfidEnabled); var state = fields.state; var singleField = state.length <= 0; // TODO: can't be used with non-selectable countries, e.g. CC var country = fields.country; // only set url after determining whether request.term is an actual zip or not var matchesZipRegex = that.matchesZipRegex(request.term); var path = null; var args = null; if (allowZipcodes && matchesZipRegex) { path = allowStates ? '/geoac/s/cosz' : '/geoac/s/cz'; } else { path = allowStates ? '/geoac/s/cos' : '/geoac/s/c'; } args = { ll: that.getLonLatArg(), t: request.term }; if (gfidTermlist.length > 0 && !that.isBlank(gfidTermlist.val())) { args.tl = gfidTermlist.val(); } var url = that.getAppUrl(path); //that.log(\"querying \" + url + \", args: \" + args.lon + \", \" + args.lat + \", \" + args.countryCode + \", \" + args.cityOrZip + \", \" + args.city); //jQuery.getJSON(url, args, function(results) { jQuery.ajax({url: url, data: args, dataType: \"json\", timeout: 2000, success: function(results) { if (results.error == \"error\") { //that.log(\"autocomplete offline, setting error\"); city.removeClass(\"cityLoading citySelect cityNotFound\"); that.signalError(gfid); response(null); return; } if (results.length == 0) { // not-found zipcodes are now disallowed // TODO: test not found: city, condensed-zip, condensed-city, zip //if (!allowZipcodes || !matchesZipRegex) { city.removeClass(\"cityLoading citySelect\").addClass(\"cityNotFound\"); //} else { //	city.removeClass(\"cityLoading citySelect\"); //} response(null); return; } response(jQuery.map(results, function (n) { zips = n.zipcode; // try to display the city zipcode, either the first found if !allowZipcodes or the one typed (if found) if (zips != null && zips.constructor.toString().indexOf(\"Array\") != -1 && zips.length > 0) { zip = zips[0]; if (matchesZipRegex) { for (i = 0; i < zips.length; i++) { if (request.term == zips[i]) { zip = zips[i]; break; } } } } else { zip = \"\"; } if (n.placetype == 'GAIC') { adm1_label = n.country_code == \"US\" ? n.adm1_code : n.adm1_name; adm1_label = that.isBlank(adm1_label) ? \"\" : \", \" + adm1_label; adm1_value = n.adm1_name; adm1_value = that.isBlank(adm1_value) ? \"\" : \", \" + adm1_value; //// always show zip to help discriminate among same-named csubs //zipPre = zip != null && zip.length > 0 ? \"(\" + zip + \") \" : \"\"; //option_label = zipPre + n.name.toLowerCase() + adm1_label; option_label = n.name.toLowerCase() + adm1_label.toLowerCase(); option_value = singleField ? n.name.toLowerCase() + adm1_value.toLowerCase() : n.name.toLowerCase(); //} else if (n.placetype == 'CSUB') { } else if (n.placetype == 'GALI') { adm1_label = n.country_code == \"US\" ? n.adm1_code : n.adm1_name; adm1_label = that.isBlank(adm1_label) ? \"\" : \", \" + adm1_label; adm1_value = n.adm1_name; adm1_value = that.isBlank(adm1_value) ? \"\" : \", \" + adm1_value; adm2_label = n.adm2_name; // showing between parentheses to avoid confusion when typing ', state' adm2_label = that.isBlank(adm2_label) ? \"\" : \" (\" + adm2_label + \")\"; adm2_value = n.adm2_name; // 'countyname county' disrupts the search //adm2_value = that.isBlank(adm2_value) ? \"\" : \", \" + adm2_value + \" COUNTY\"; adm2_value = that.isBlank(adm2_value) ? \"\" : \", \" + adm2_value; //// always show zip to help discriminate among same-named csubs //zipPre = zip != null && zip.length > 0 ? \"(\" + zip + \") \" : \"\"; //option_label = zipPre + n.name.toLowerCase() + adm1_label + adm2_label.toLowerCase(); option_label = n.name.toLowerCase() + adm1_label.toLowerCase() + adm2_label.toLowerCase(); option_value = singleField ? n.name.toLowerCase() + adm2_value.toLowerCase() + adm1_value.toLowerCase() : n.name.toLowerCase(); //} else if (n.placetype == 'CITY') { } else if (n.placetype == 'GZIP') { adm1_label = n.country_code == \"US\" ? n.adm1_code : n.adm1_name; adm1_label = that.isBlank(adm1_label) ? \"\" : \", \" + adm1_label; adm1_value = n.adm1_name; adm1_value = that.isBlank(adm1_value) ? \"\" : \", \" + adm1_value; adm2_label = n.adm2_name; // showing between parentheses to avoid confusion when typing ', state' adm2_label = that.isBlank(adm2_label) ? \"\" : \" (\" + adm2_label + \")\"; adm2_value = n.adm2_name; // 'countyname county' disrupts the search //adm2_value = that.isBlank(adm2_value) ? \"\" : \", \" + adm2_value + \" COUNTY\"; adm2_value = that.isBlank(adm2_value) ? \"\" : \", \" + adm2_value; //zipPre = matchesZipRegex && zip != null && zip.length > 0 ? \"(\" + zip + \") \" : \"\"; //option_label = zipPre + n.name.toLowerCase() + adm1_label + adm2_label.toLowerCase(); //option_value = singleField ? n.name.toLowerCase() + adm2_value.toLowerCase() + adm1_value.toLowerCase() : n.name.toLowerCase(); option_label = n.name.toLowerCase() + adm1_label.toLowerCase() + adm2_label.toLowerCase(); option_value = singleField ? n.name.toLowerCase() : n.name.toLowerCase(); } else if (n.placetype == 'ADM2') { adm1_label = n.country_code == \"US\" ? n.adm1_code : n.adm1_name; adm1_label = that.isBlank(adm1_label) ? \"\" : \", \" + adm1_label; adm1_value = n.adm1_name; adm1_value = that.isBlank(adm1_value) ? \"\" : \", \" + adm1_value; adm2_label = n.name; adm2_label = that.isBlank(adm2_label) ? \"\" : adm2_label + \" COUNTY\"; adm2_value = n.name; adm2_value = that.isBlank(adm2_value) ? \"\" : adm2_value + \" COUNTY\"; option_label = adm2_label.toLowerCase() + adm1_label.toLowerCase(); option_value = adm2_value.toLowerCase() + adm1_value.toLowerCase(); } else if (n.placetype == 'ADM1') { adm1_label = n.name; adm1_label = that.isBlank(adm1_label) ? \"\" : n.country_code == \"US\" ? \"STATE OF \" + adm1_label : adm1_label; adm1_value = n.name; adm1_value = that.isBlank(adm1_value) ? \"\" : n.country_code == \"US\" ? \"STATE OF \" + adm1_value : adm1_value; option_label = adm1_label.toLowerCase(); option_value = adm1_value.toLowerCase(); } else { option_label = n.name.toLowerCase(); option_value = n.name.toLowerCase(); } //alert(matchesZipRegex +\",\"+zip+\",\"+\"->\"+zipPre); // - query zip: label '(zip) city, statecode (county)', value 'city, countyname, statename' // - query city: label 'city, statecode (county)', value 'city, countyname, statename' // - query county: label 'countyname county, statecode', value 'countyname county, statename' // - query state: label 'state of statename', value 'state of statename' // avoid lower-casing statecodes in labels //option_label = option_label.toLowerCase(); /*// if singleField, use city, state as value, otherwise, place each separately option_value = (singleField && n.placetype != 'ADM1') ? n.name + adm1 + adm2 : n.name;*/ // if !singleField, place each field value separately; if singleField and // - query is a zip, leave the zip and rely on the unified geo db (geoloc zips but gf latlons, 0) ? zip : //	(singleField && n.placetype != 'ADM1') ? n.name + adm1 : //	n.placetype != 'ADM1' ? n.name : adm1; return { label: option_label, value: option_value, //gfid: n.feature_id, gfid: n.gac_id, name: n.name.toLowerCase(), state: n.adm1_name, postalCode: zip, country: n.country_code, countryName: n.country_name }; })); }, error: function(jqXHR, textStatus, errorThrown) { if (textStatus == 'timeout') { jqXHR.abort(); } //that.log(\"autocomplete error '\" + textStatus + \"', setting error\"); city.removeClass(\"cityLoading citySelect cityNotFound\"); that.signalError(gfid); response(null); }}); }, create: function(event, ui) { //var fields = that.fields(isThisCity, this); var fields = that.fieldsFromEvent(isThisCity, event); var city = fields.city; var gfid = fields.gfid; var state = fields.state; var postalCode = fields.postalCode; var country = fields.country; var asiuc = that.signalsAllowSubmitIfUnchanged(gfid); if (!asiuc && gfid.length > 0) { if (that.isBlank(gfid.val())) { city.val(\"\"); postalCode.val(\"\"); } } // this autocomplete implies that state is derived from other fields that.stateDisable(state); that.countryPreselect(country); }, search: function(event, ui) { //var fields = that.fields(isThisCity, this); var fields = that.fieldsFromEvent(isThisCity, event); var city = fields.city; var gfid = fields.gfid; var state = fields.state; var country = fields.country; var countryName = fields.countryName; var asiuc = that.signalsAllowSubmitIfUnchanged(gfid); if (!asiuc) { //that.log(\"search: clearing gfid\"); if (gfid.length > 0) gfid.val(null); if (state.length > 0) state.val(null); // country now determines //if (country.length > 0) country.val(\"\"); //if (countryName.length > 0) countryName.val(\"\"); } //var matchesZipRegex = that.matchesZipRegex(city.val()); // not-found zipcodes are now disallowed //if (!allowZipcodes || !matchesZipRegex) { city.removeClass(\"cityNotFound citySelect\").addClass(\"cityLoading\"); //} else { //	city.removeClass(\"cityNotFound cityLoading citySelect\"); //} }, open: function(event, ui) { //var fields = that.fields(isThisCity, this); var fields = that.fieldsFromEvent(isThisCity, event); var city = fields.city; city.removeClass(\"cityLoading cityNotFound\").addClass(\"citySelect\"); }, select: function(event, ui) { //var fields = that.fields(isThisCity, this); var fields = that.fieldsFromEvent(isThisCity, event); var city = fields.city; var gfid = fields.gfid; var state = fields.state; var country = fields.country; var countryName = fields.countryName; var postalCode = fields.postalCode; if (gfid.length > 0) gfid.val(ui.item.gfid); // overwriting user-given postalCode, if any (might have changed a city and should get a coherent zip) if (postalCode.length > 0) { //	if (that.isBlank(postalCode.val())) { //	if (ui.item.postalCode != null && ui.item.postalCode != \"\") { postalCode.val(ui.item.postalCode); jQuery(\".\" + postalCode.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); //	} //	} } if (state.length > 0) { state.val(ui.item.state); if (ui.item.state.length > 0) jQuery(\".\" + state.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); } // country now determines //if (country.length > 0) { //	country.val(ui.item.country); //	if (ui.item.country.length > 0) jQuery(\".\" + country.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); //} //if (countryName.length > 0) { //	countryName.val(ui.item.countryName); //	if (ui.item.countryName.length > 0) jQuery(\".\" + countryName.attr(\"id\").replace(\".\", \"_\") + \"formError\").remove(); //} // needed to actually set the textbox value when the select event has been programmatically invoked city.val(ui.item.value); city.addClass(\"ui-state-focus\"); city.removeClass(\"citySelect\"); }, change: function (event, ui) { //var fields = that.fields(isThisCity, this); var fields = that.fieldsFromEvent(isThisCity, event); var city = fields.city; var gfid = fields.gfid; var error = that.signalsError(gfid); if (error) { //that.log(\"autocomplete offline, disregarding mustMatch\"); } // pseudo mustMatch; can't do the same with close() because ui is empty // checking both ui.item and gfid.val (only if we clear gfid.val upon keyChangesValue) (when triggering select() programmatically, ui.item comes null but gfid.val keeps its value) if (!error && !ui.item && !that.checkSelection(city, alsoAllowed)) { city.val(\"\"); //that.log(\"change: clearing gfid\"); if (gfid.length > 0) gfid.val(null); } } }); if (myClass != null) { jQuery(selector).each(function(i, e) { jQuery(e).addClass(myClass); }); } else { jQuery(selector).each(function(i, e) { jQuery(e).addClass(\"defaultAutoInput\"); }); } // if execution got to this point, ui autocomplete is probably supported, let the server know it's enabled // might also try jQuery(selector).each(function() { if jQuery(this).autocomplete( \"widget\" ) then enable ? }); if (jQuery('ul.ui-autocomplete').length > 0) { jQuery(selector).each(function() { var cityElement = jQuery(this); var fields = that.fields(isThisCity, cityElement); var gfidEnabled = fields.gfidEnabled; that.enable(gfidEnabled); }); } }; };*AboutOur CompanyTerms of ServicePrivacy PolicyCookies In Use on This SiteDo Not Sell My Personal InformationEmployersOur SolutionsPost Single JobsUnlimited Job PostingsCompliance SolutionsSupported ATSEmployers’ LoginAccount Management TutorialsJobs SeekersSearch JobsUpload Your ResumeCareer AdviceTop SearchesTop Diversity EmployersCollege & University PartnersDiversity InsightsCopyright © DiversityJobs.comTop EmployersJob FairsArticlesCareer AdviceWorkplace DiversityCareer StoriesEmployers / Post JobsFind JobsUpload ResumeCompany InfoOur CompanyGiving BackTerms of ServicePrivacy PolicyCookiesContact UsEmployers & AdvertisersLoginPost Single Job NowSee All Employer OptionsPublishersLink to usSearch BoxJob Box"
