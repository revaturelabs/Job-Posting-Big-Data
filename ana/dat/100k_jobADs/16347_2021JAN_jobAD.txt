"Introducing API Shield - Engineering NewsNewsAbout UsJobsContact UsFAQsFacebookTwitterInstagramRSS.advertise@offshoreoiljobs.co.uk.www.offshoreoiljobs.co.ukFacebookTwitterInstagramRSSGet a quoteNewsAbout UsJobsContact UsFAQsSearch for:Search for: Search:Introducing API ShieldEngineering NewsEngineering NewsComputer EngineeringIntroducing API ShieldShareFacebookTwitterLinkedInGoogle+EmailDon't Hesitate To AskRequest A Quick QuoteIntroducing API ShieldOctober 1, 2020 posted by engineering Category: Computer Engineering, Electronics EngineeringAPIs are the lifeblood of modern Internet-connected applications. Every millisecond they carry requests from mobile applications—place this food delivery order, “like” this picture—and directions to IoT devices—unlock the car door, start the wash cycle, my human just finished a 5k run—among countless other calls.They’re also the target of widespread attacks designed to perform unauthorized actions or exfiltrate data, as data from Gartner increasingly shows: “by 2021, 90% of web-enabled applications will have more surface area for attack in the form of exposed APIs rather than the UI, up from 40% in 2019, and “Gartner predicted that, by 2022, API abuses will move from an infrequent to the most-frequent attack vector, resulting in data breaches for enterprise web applications”[1][2]. Of the 18 million requests per second that traverse Cloudflare’s network, 50% are directed towards APIs—with the majority of these requests blocked as malicious.To combat these threats, Cloudflare is making it simple to secure APIs through the use of strong client certificate-based identity and strict schema-based validation. As of today, these capabilities are available free for all plans within our new “API Shield” offering. And as of today, the security benefits also extend to gRPC-based APIs, which use binary formats such as protocol buffers rather than JSON, and have been growing in popularity with our customer base.Continue reading to learn more about the new capabilities, or jump right to the “Demonstration” paragraph for examples of how to get started configuring your first API Shield rule.Positive security models and client certificatesA “positive security” model is one that allows only known behavior and identities, while rejecting everything else. It is the opposite of the traditional “negative security” model enforced by a Web Application Firewall (WAF) that allows everything except for requests coming from problematic IPs, ASNs, countries or requests with problematic signatures (SQL injection attempts, etc.).Implementing a positive security model for APIs is the most direct way to eliminate the noise of credential stuffing attacks and other automated scanning tools. And the first step towards a positive model is deploying strong authentication such as mutual TLS authentication, which is not vulnerable to the reuse or sharing of passwords.Just as we simplified the issuance of server certificates back in 2014 with Universal SSL, API Shield reduces the process of issuing client certificates to clicking a few buttons in the Cloudflare Dashboard. By providing a fully hosted private public key infrastructure (PKI), you can focus on your applications and features—rather than operating and securing your own certificate authority (CA).Enforcing valid requests with schema validationOnce developers can be sure that only legitimate clients (with SSL certificates in hand) are connecting to their APIs, the next step in implementing a positive security model is making sure that those clients are making valid requests. Extracting a client certificate from a device and reusing elsewhere is difficult, but not impossible, so it’s also important to make sure that the API is being called as intended.Requests containing extraneous input may not have been anticipated by the API developer, and can cause problems if processed directly by the application, so these should be dropped at the edge if possible. API Schema validation works by matching the contents of API requests—the query parameters that come after the URL and contents of the POST body—against a contract or “schema” that contains the rules for what is expected. If validation fails, the API call is blocked protecting the origin from an invalid request or a malicious payload.Schema validation is currently in closed beta for JSON payloads, with gRPC/protocol buffer support on the roadmap. If you would like to join the beta please open a support ticket with the subject “API Schema Validation Beta”. After the beta has ended, we plan to make schema validation available as part of the API Shield user interface.DemonstrationTo demonstrate how the APIs powering IoT devices and mobile applications can be secured, we have built an API Shield demonstration using client certificates and schema validation.Temperatures are captured by an IoT device, represented in the demo by a Raspberry Pi 3 Model B+ with an external infrared temperature sensor, and then transmitted via a POST request to a Cloudflare-protected API. Temperatures are subsequently retrieved by GET requests and then displayed in a mobile application built in Swift for iOS.In both cases, the API was actually built using Cloudflare Workers® and Workers KV, but can be replaced by any Internet-accessible endpoint.1. API ConfigurationBefore configuring the IoT device and mobile application to communicate securely with the API, we need to bootstrap the API endpoints. To keep the example simple, while also allowing for additional customization, we’ve implemented the API as a Cloudflare Worker (borrowing code from the To-Do List tutorial).In this particular example the temperatures are stored in Workers KV using the source IP address as a key, but this could easily be replaced by a value from the client certificate, e.g., the fingerprint. The code below saves a temperature and timestamp into KV when a POST is made, and returns the most recent 5 temperatures when a GET request is made.const defaultData = { temperatures: [] }const getCache = key => TEMPERATURES.get(key)const setCache = (key, data) => TEMPERATURES.put(key, data)async function addTemperature(request) {    // pull previously recorded temperatures for this client    const ip = request.headers.get('CF-Connecting-IP')    const cacheKey = `data-${ip}`    let data    const cache = await getCache(cacheKey)    if (!cache) {        await setCache(cacheKey, JSON.stringify(defaultData))        data = defaultData    } else {        data = JSON.parse(cache)    }    // append the recorded temperatures with the submitted reading (assuming it has both temperature and a timestamp)    try {        const body = await request.text()        const val = JSON.parse(body)        if (val.temperature && val.time) {            data.temperatures.push(val)            await setCache(cacheKey, JSON.stringify(data))            return new Response(\"\", { status: 201 })        } else {            return new Response(\"Unable to parse temperature and/or timestamp from JSON POST body\", { status: 400 })        }    } catch (err) {        return new Response(err, { status: 500 })    }}function compareTimestamps(a,b) {    return -1 * (Date.parse(a.time) - Date.parse(b.time))}// return the 5 most recent temperature measurementsasync function getTemperatures(request) {    const ip = request.headers.get('CF-Connecting-IP')    const cacheKey = `data-${ip}`    const cache = await getCache(cacheKey)    if (!cache) {        return new Response(JSON.stringify(defaultData), { status: 200, headers: { 'content-type': 'application/json' } })    } else {        data = JSON.parse(cache)        const retval = JSON.stringify(data.temperatures.sort(compareTimestamps).splice(0,5))        return new Response(retval, { status: 200, headers: { 'content-type': 'application/json' } })    }}async function handleRequest(request) {    if (request.method === 'POST') {        return addTemperature(request)    } else {        return getTemperatures(request)    }}addEventListener('fetch', event => {  event.respondWith(handleRequest(event.request))})Before adding mutual TLS authentication, we’ll test POST’ing a random temperature reading:$ TEMPERATURE=$(echo $((361 + RANDOM %11)) | awk '{printf(\"%.2f\",$1/10.0)}')$ TIMESTAMP=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")$ echo -e \"$TEMPERATUREn$TIMESTAMP\"36.302020-09-28T02:57:49Z$ curl -v -H \"Content-Type: application/json\" -d '{\"temperature\":'''$TEMPERATURE''', \"time\": \"'''$TIMESTAMP'''\"}' https://shield.upinatoms.com/temps 2>&1 | grep \"< HTTP/2\"< HTTP/2 201And here’s a subsequent read of that temperature, along with the previous 4 that were submitted:$ curl -s https://shield.upinatoms.com/temps | jq .[  {    \"temperature\": 36.3,    \"time\": \"2020-09-28T02:57:49Z\"  },  {    \"temperature\": 36.7,    \"time\": \"2020-09-28T02:54:56Z\"  },  {    \"temperature\": 36.2,    \"time\": \"2020-09-28T02:33:08Z\"  },    {    \"temperature\": 36.5,    \"time\": \"2020-09-28T02:29:22Z\"  },  {    \"temperature\": 36.9,    \"time\": \"2020-09-28T02:27:19Z\"  } ]2. Client certificate issuanceWith our API in hand, it’s time to lock it down to require a valid client certificate. Before doing so we’ll want to generate those certificates. To do so, you can either go to the SSL/TLS → Client Certificates tab of the Cloudflare Dashboard and click “Create Certificate” or you can automate the process via API calls.Because most developers at scale will be generating their own private keys and CSRs and requesting that they be signed via API, we’ll show that process here. Using Cloudflare’s PKI toolkit CFSSL we’ll first create a bootstrap certificate fo the iOS application, and then we’ll create a certificate for the IoT device:$ cat <<'EOF' | tee -a csr.json{    \"hosts\": [        \"ios-bootstrap.devices.upinatoms.com\"    ],    \"CN\": \"ios-bootstrap.devices.upinatoms.com\",    \"key\": {        \"algo\": \"rsa\",        \"size\": 2048    },    \"names\": [{        \"C\": \"US\",        \"L\": \"Austin\",        \"O\": \"Temperature Testers, Inc.\",        \"OU\": \"Tech Operations\",        \"ST\": \"Texas\"    }]}EOF$ cfssl genkey csr.json | cfssljson -bare certificate2020/09/27 21:28:46 [INFO] generate received request2020/09/27 21:28:46 [INFO] received CSR2020/09/27 21:28:46 [INFO] generating key: rsa-20482020/09/27 21:28:47 [INFO] encoded CSR$ mv certificate-key.pem ios-key.pem$ mv certificate.csr ios.csr// and do the same for the IoT sensor$ sed -i.bak 's/ios-bootstrap/sensor-001/g' csr.json$ cfssl genkey csr.json | cfssljson -bare certificate...$ mv certificate-key.pem sensor-key.pem$ mv certificate.csr sensor.csrGenerate a private key and CSR for the IoT device and iOS application// we need to replace actual newlines in the CSR with ‘n’ before POST’ing$ CSR=$(cat ios.csr | perl -pe 's/n/\\n/g')$ request_body=$(< <(cat <<EOF{  \"validity_days\": 3650,  \"csr\":\"$CSR\"}EOF))// save the response so we can view it and then extract the certificate$ curl -H 'X-Auth-Email: YOUR_EMAIL' -H 'X-Auth-Key: YOUR_API_KEY' -H 'Content-Type: application/json' -d “$request_body” https://api.cloudflare.com/client/v4/zones/YOUR_ZONE_ID/client_certificates > response.json$ cat response.json | jq .{  \"success\": true,  \"errors\": [],  \"messages\": [],  \"result\": {    \"id\": \"7bf7f70c-7600-42e1-81c4-e4c0da9aa515\",    \"certificate_authority\": {      \"id\": \"8f5606d9-5133-4e53-b062-a2e5da51be5e\",      \"name\": \"Cloudflare Managed CA for account 11cbe197c050c9e422aaa103cfe30ed8\"    },    \"certificate\": \"-----BEGIN CERTIFICATE-----nMIIEkzCCA...n-----END CERTIFICATE-----n\",    \"csr\": \"-----BEGIN CERTIFICATE REQUEST-----nMIIDITCCA...n-----END CERTIFICATE REQUEST-----n\",    \"ski\": \"eb2a48a19802a705c0e8a39489a71bd586638fdf\",    \"serial_number\": \"133270673305904147240315902291726509220894288063\",    \"signature\": \"SHA256WithRSA\",    \"common_name\": \"ios-bootstrap.devices.upinatoms.com\",    \"organization\": \"Temperature Testers, Inc.\",    \"organizational_unit\": \"Tech Operations\",    \"country\": \"US\",    \"state\": \"Texas\",    \"location\": \"Austin\",    \"expires_on\": \"2030-09-26T02:41:00Z\",    \"issued_on\": \"2020-09-28T02:41:00Z\",    \"fingerprint_sha256\": \"84b045d498f53a59bef53358441a3957de81261211fc9b6d46b0bf5880bdaf25\",    \"validity_days\": 3650  }}$ cat response.json | jq .result.certificate | perl -npe 's/\\n/n/g; s/\"//g' > ios.pem// now ask that the second client certificate signing request be signed$ CSR=$(cat sensor.csr | perl -pe 's/n/\\n/g')$ request_body=$(< <(cat <<EOF{  \"validity_days\": 3650,  \"csr\":\"$CSR\"}EOF))$ curl -H 'X-Auth-Email: YOUR_EMAIL' -H 'X-Auth-Key: YOUR_API_KEY' -H 'Content-Type: application/json' -d \"$request_body\" https://api.cloudflare.com/client/v4/zones/YOUR_ZONE_ID/client_certificates | perl -npe 's/\\n/n/g; s/\"//g' > sensor.pemAsk Cloudflare to sign the CSRs with the private CA issued for your zone3. API Shield rule creationWith certificates in hand we can now configure the API endpoint to require their use. Below is a demonstration of how to create such a rule.The steps include specifying which hostnames to prompt for certificates, e.g., shield.upinatoms.com, and then creating the API Shield rule.4. IoT Device CommunicationTo prepare the IoT device for secure communication with our API endpoint we need to embed the certificate on the device, and then point our application to it so it can be used when making the POST request to the API endpoint.We securely copied the private key and certificate into /etc/ssl/private/sensor-key.pem and /etc/ssl/certs/sensor.pem, and then modified our sample script to point to these files:import requestsimport jsonfrom datetime import datetimedef readSensor():    # Takes a reading from a temperature sensor and store it to temp_measurement     dateTimeObj = datetime.now()    timestampStr = dateTimeObj.strftime(‘%Y-%m-%dT%H:%M:%SZ’)    measurement = {'temperature':str(36.5),'time':timestampStr}    return measurementdef main():    print(\"Cloudflare API Shield [IoT device demonstration]\")    temperature = readSensor()    payload = json.dumps(temperature)    url = 'https://shield.upinatoms.com/temps'    json_headers = {'Content-Type': 'application/json'}    cert_file = ('/etc/ssl/certs/sensor.pem', '/etc/ssl/private/sensor-key.pem')    r = requests.post(url, headers = json_headers, data = payload, cert = cert_file)    print(\"Request body: \", r.request.body)    print(\"Response status code: %d\" % r.status_code)When the script attempts to connect to https://shield.upinatoms.com/temps, Cloudflare requests that a ClientCertificate is sent, and our script sends the contents of sensor.pem before demonstrating it has possession of sensor-key.pem as required to complete the SSL/TLS handshake.If we fail to send the client certificate or attempt to include extraneous fields in the API request, the schema validation (configuration not shown) fails and the request is rejected:Cloudflare API Shield [IoT device demonstration]Request body:  {\"temperature\": \"36.5\", \"time\": \"2020-09-28T15:52:19Z\"}Response status code: 403If instead a valid certificate is presented and the payload follows the schema previously uploaded, our script POSTs the latest temperature reading to the API.Cloudflare API Shield [IoT device demonstration]Request body:  {\"temperature\": \"36.5\", \"time\": \"2020-09-28T15:56:45Z\"}Response status code: 2015. Mobile Application (iOS) CommunicationNow that temperature requests have been sent to our API endpoint, it’s time to read them securely from our mobile application using one of the client certificates.For purposes of brevity, we’re going to embed a “bootstrap” certificate and key as a PKCS#12 file within the application bundle. In a real world deployment, this bootstrap certificate should only be used alongside users’ credentials to authenticate to an API endpoint that can return a unique user certificate. Corporate users will want to use MDM to distribute certificates so that the underlying mobilePackage the certificate and private keyBefore adding the bootstrap certificate and private key, we need to combine them into a binary PKCS#12 file. This binary file will then be added to our iOS application bundle.$ openssl pkcs12 -export -out bootstrap-cert.pfx -inkey ios-key.pem -in ios.pemEnter Export Password:Verifying - Enter Export Password:Add the certificate bundle to your iOS applicationWithin XCode, click File → Add Files To “[Project Name]” and select your .pfx file. Make sure to check “Add to target” before confirming.Modify your URLSession code to use the client certificateThis article provides a nice walkthrough of using a PKCS#11 class and URLSessionDelegate to modify your application to complete mutual TLS authentication when connecting to an API that requires it.Looking ForwardIn the coming months, we plan to expand API Shield with a number of additional features designed to protect API traffic. For customers that want to use their own PKI, we will provide the ability to import their own CAs, something available today as part of Cloudflare Access.As we receive feedback on our schema validation beta, we will look to make the capability generally available to all customers. If you’re trying out the beta and have thoughts to share, we’d love to hear your feedback.Beyond certificates and schema validation, we’re excited to layer on additional API security capabilities as well as deep analytics to help you better understand your APIs. If you there are features you’d like to see, let us know in the comments below!1: “By 2021, 90% of web-enabled applications will have more surface area for attack in the form of exposed APIs rather than the UI, up from 40% in 2019. Source: Gartner “Gartner’s API Strategy Maturity Model”, Saniye Alaybeyi, Mark O’Neill, October 21, 2019. (Gartner subscription required)2: “Gartner predicted by 2022, API abuses will move from an infrequent to the most-frequent attack vector, resulting in data breaches for enterprise web applications. Source: Gartner “Cool Vendors in API Strategy”, Shameen Pillai, Paolo Malinverno, Mark O’Neill, Jeremy D’Hoinne, May 18, 2020 (Gartner subscription required)Source linkShare this:Click to share on Twitter (Opens in new window)Click to share on Facebook (Opens in new window)Click to share on Google+ (Opens in new window)RelatedShareSearch for:CategoriesAerospace EngineeringAgricultural EngineeringBiomedical EngineeringChemical EngineeringCivil EngineeringComputer EngineeringConstruction EngineeringElectrical EngineeringElectronics EngineeringEnvironmental EngineeringGeotechnical EngineeringMaterial EngineeringMechanical EngineeringPetroleum and GasPetroleum EngineeringTelecommunications EngineeringRecent NewsHydrogen gas-fueled airships could spur development in remote communities January 22, 2021Air Force issues national call for 3-D scanner January 22, 2021Introducing Lyft’s Mexico City Engineering Office | by Chris Lambert | Jan, 2021 January 21, 2021You have a question?And Need Our Help?Contact UsAbout UsWe provide expert industrial solutions to businesses. With over 20 years of experience we’ll ensure that you’re always getting the best results from an award-winning US firm focused on quality.Visit our sister site www.offshoreoiljobs.co.uk to find the latest oil and gas, maritime and energy jobs worldwide.NavigationNewsAbout UsJobsContact UsFAQsLatest NewsHydrogen gas-fueled airships could spur development in remote communities January 22, 2021Air Force issues national call for 3-D scanner January 22, 2021Introducing Lyft’s Mexico City Engineering Office | by Chris Lambert | Jan, 2021 January 21, 2021Budget-split testing: A trustworthy and powerful approach to marketplace A/B testing January 21, 2021Follow UsFacebookTwitterInstagramRSS© 2017 - engineeringjobs4u. All Rights Reserved.Powered by Mr. Raymond"
